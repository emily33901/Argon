using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using ArgonCore;

namespace DelegateGenerator
{
    /// <summary>
    /// <para>This program is for creating a class of delegates from an interface implementation.</para>
    /// <para>The resulting classes will be in the form of the name that the class implements with the correct attributes applied</para>
    /// </summary>
    /// <remarks>
    /// In order for this to work properly ALL interface plugins need to be added as dependencies to this program
    /// </remarks>
    class Program
    {
        class DelegateDefinition
        {
            public string name;
            public string return_type;

            // stored in the form (type, name)
            public List<(string, string)> args;

            public DelegateDefinition()
            {
                args = new List<(string, string)>();
            }
        }

        static string file_prolog =
@"using System;
// Autogenerated!
namespace {0}
{{
    /// <summary>
    /// Exports the delegates for all interfaces that implement {1}
    /// </summary>
    [ArgonCore.InterfaceDelegate(Name = ""{1}"")]
    class {1}_Delegates
    {{";

        static string file_epilog = 
@"    }
}";

        // TODO: This program should be taking dlls at runtime and not references at compile time!
        static void Main(string[] args)
        {
            foreach (var a in InterfaceLoader.GetInterfaceAssemblies())
            {
                foreach (var type in a.GetTypes())
                {
                    if (InterfaceLoader.IsInterfaceImpl(type))
                    {
                        var impl_attribute = type.GetCustomAttribute<InterfaceImplAttribute>();

                        // Print file prolog
                        Console.WriteLine(file_prolog, type.Namespace, impl_attribute.Implements);

                        var new_delegates = new List<DelegateDefinition>();

                        var methods = InterfaceLoader.InterfaceMethodsForType(type);

                        foreach (var mi in methods)
                        {
                            var new_delegate = new DelegateDefinition();

                            new_delegate.name = mi.Name + "Delegate";

                            new_delegate.return_type = mi.ReturnType.Name;

                            foreach (var param in mi.GetParameters())
                            {
                                new_delegate.args.Add((param.ParameterType.Name, param.Name));
                            }

                            new_delegates.Add(new_delegate);
                        }

                        foreach (var del in new_delegates)
                        {
                            Console.Write("        public delegate {0} {1}(", del.return_type, del.name);
                            for (var i = 0; i < del.args.Count; i++)
                            {
                                var (t, name) = del.args[i];

                                Console.Write("{0} {1}", t, name);

                                if (i != del.args.Count - 1)
                                {
                                    Console.Write(", ");
                                }
                            }

                            Console.WriteLine(");");
                        }

                        Console.WriteLine(file_epilog);
                    }
                }
            }

            Console.ReadLine();
        }
    }
}
